// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'internet_cubit.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$InternetState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() unknown,
    required TResult Function() connected,
    required TResult Function() offline,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? unknown,
    TResult? Function()? connected,
    TResult? Function()? offline,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? unknown,
    TResult Function()? connected,
    TResult Function()? offline,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialInternetState value) initial,
    required TResult Function(_UnknownInternetState value) unknown,
    required TResult Function(_ConnectedInternetState value) connected,
    required TResult Function(_OfflineInternetState value) offline,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InitialInternetState value)? initial,
    TResult? Function(_UnknownInternetState value)? unknown,
    TResult? Function(_ConnectedInternetState value)? connected,
    TResult? Function(_OfflineInternetState value)? offline,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialInternetState value)? initial,
    TResult Function(_UnknownInternetState value)? unknown,
    TResult Function(_ConnectedInternetState value)? connected,
    TResult Function(_OfflineInternetState value)? offline,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InternetStateCopyWith<$Res> {
  factory $InternetStateCopyWith(
          InternetState value, $Res Function(InternetState) then) =
      _$InternetStateCopyWithImpl<$Res, InternetState>;
}

/// @nodoc
class _$InternetStateCopyWithImpl<$Res, $Val extends InternetState>
    implements $InternetStateCopyWith<$Res> {
  _$InternetStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_InitialInternetStateCopyWith<$Res> {
  factory _$$_InitialInternetStateCopyWith(_$_InitialInternetState value,
          $Res Function(_$_InitialInternetState) then) =
      __$$_InitialInternetStateCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_InitialInternetStateCopyWithImpl<$Res>
    extends _$InternetStateCopyWithImpl<$Res, _$_InitialInternetState>
    implements _$$_InitialInternetStateCopyWith<$Res> {
  __$$_InitialInternetStateCopyWithImpl(_$_InitialInternetState _value,
      $Res Function(_$_InitialInternetState) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_InitialInternetState extends _InitialInternetState {
  const _$_InitialInternetState() : super._();

  @override
  String toString() {
    return 'InternetState.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_InitialInternetState);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() unknown,
    required TResult Function() connected,
    required TResult Function() offline,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? unknown,
    TResult? Function()? connected,
    TResult? Function()? offline,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? unknown,
    TResult Function()? connected,
    TResult Function()? offline,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialInternetState value) initial,
    required TResult Function(_UnknownInternetState value) unknown,
    required TResult Function(_ConnectedInternetState value) connected,
    required TResult Function(_OfflineInternetState value) offline,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InitialInternetState value)? initial,
    TResult? Function(_UnknownInternetState value)? unknown,
    TResult? Function(_ConnectedInternetState value)? connected,
    TResult? Function(_OfflineInternetState value)? offline,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialInternetState value)? initial,
    TResult Function(_UnknownInternetState value)? unknown,
    TResult Function(_ConnectedInternetState value)? connected,
    TResult Function(_OfflineInternetState value)? offline,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _InitialInternetState extends InternetState {
  const factory _InitialInternetState() = _$_InitialInternetState;
  const _InitialInternetState._() : super._();
}

/// @nodoc
abstract class _$$_UnknownInternetStateCopyWith<$Res> {
  factory _$$_UnknownInternetStateCopyWith(_$_UnknownInternetState value,
          $Res Function(_$_UnknownInternetState) then) =
      __$$_UnknownInternetStateCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_UnknownInternetStateCopyWithImpl<$Res>
    extends _$InternetStateCopyWithImpl<$Res, _$_UnknownInternetState>
    implements _$$_UnknownInternetStateCopyWith<$Res> {
  __$$_UnknownInternetStateCopyWithImpl(_$_UnknownInternetState _value,
      $Res Function(_$_UnknownInternetState) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_UnknownInternetState extends _UnknownInternetState {
  const _$_UnknownInternetState() : super._();

  @override
  String toString() {
    return 'InternetState.unknown()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_UnknownInternetState);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() unknown,
    required TResult Function() connected,
    required TResult Function() offline,
  }) {
    return unknown();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? unknown,
    TResult? Function()? connected,
    TResult? Function()? offline,
  }) {
    return unknown?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? unknown,
    TResult Function()? connected,
    TResult Function()? offline,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialInternetState value) initial,
    required TResult Function(_UnknownInternetState value) unknown,
    required TResult Function(_ConnectedInternetState value) connected,
    required TResult Function(_OfflineInternetState value) offline,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InitialInternetState value)? initial,
    TResult? Function(_UnknownInternetState value)? unknown,
    TResult? Function(_ConnectedInternetState value)? connected,
    TResult? Function(_OfflineInternetState value)? offline,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialInternetState value)? initial,
    TResult Function(_UnknownInternetState value)? unknown,
    TResult Function(_ConnectedInternetState value)? connected,
    TResult Function(_OfflineInternetState value)? offline,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class _UnknownInternetState extends InternetState {
  const factory _UnknownInternetState() = _$_UnknownInternetState;
  const _UnknownInternetState._() : super._();
}

/// @nodoc
abstract class _$$_ConnectedInternetStateCopyWith<$Res> {
  factory _$$_ConnectedInternetStateCopyWith(_$_ConnectedInternetState value,
          $Res Function(_$_ConnectedInternetState) then) =
      __$$_ConnectedInternetStateCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_ConnectedInternetStateCopyWithImpl<$Res>
    extends _$InternetStateCopyWithImpl<$Res, _$_ConnectedInternetState>
    implements _$$_ConnectedInternetStateCopyWith<$Res> {
  __$$_ConnectedInternetStateCopyWithImpl(_$_ConnectedInternetState _value,
      $Res Function(_$_ConnectedInternetState) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_ConnectedInternetState extends _ConnectedInternetState {
  const _$_ConnectedInternetState() : super._();

  @override
  String toString() {
    return 'InternetState.connected()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ConnectedInternetState);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() unknown,
    required TResult Function() connected,
    required TResult Function() offline,
  }) {
    return connected();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? unknown,
    TResult? Function()? connected,
    TResult? Function()? offline,
  }) {
    return connected?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? unknown,
    TResult Function()? connected,
    TResult Function()? offline,
    required TResult orElse(),
  }) {
    if (connected != null) {
      return connected();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialInternetState value) initial,
    required TResult Function(_UnknownInternetState value) unknown,
    required TResult Function(_ConnectedInternetState value) connected,
    required TResult Function(_OfflineInternetState value) offline,
  }) {
    return connected(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InitialInternetState value)? initial,
    TResult? Function(_UnknownInternetState value)? unknown,
    TResult? Function(_ConnectedInternetState value)? connected,
    TResult? Function(_OfflineInternetState value)? offline,
  }) {
    return connected?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialInternetState value)? initial,
    TResult Function(_UnknownInternetState value)? unknown,
    TResult Function(_ConnectedInternetState value)? connected,
    TResult Function(_OfflineInternetState value)? offline,
    required TResult orElse(),
  }) {
    if (connected != null) {
      return connected(this);
    }
    return orElse();
  }
}

abstract class _ConnectedInternetState extends InternetState {
  const factory _ConnectedInternetState() = _$_ConnectedInternetState;
  const _ConnectedInternetState._() : super._();
}

/// @nodoc
abstract class _$$_OfflineInternetStateCopyWith<$Res> {
  factory _$$_OfflineInternetStateCopyWith(_$_OfflineInternetState value,
          $Res Function(_$_OfflineInternetState) then) =
      __$$_OfflineInternetStateCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_OfflineInternetStateCopyWithImpl<$Res>
    extends _$InternetStateCopyWithImpl<$Res, _$_OfflineInternetState>
    implements _$$_OfflineInternetStateCopyWith<$Res> {
  __$$_OfflineInternetStateCopyWithImpl(_$_OfflineInternetState _value,
      $Res Function(_$_OfflineInternetState) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_OfflineInternetState extends _OfflineInternetState {
  const _$_OfflineInternetState() : super._();

  @override
  String toString() {
    return 'InternetState.offline()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_OfflineInternetState);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() unknown,
    required TResult Function() connected,
    required TResult Function() offline,
  }) {
    return offline();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? unknown,
    TResult? Function()? connected,
    TResult? Function()? offline,
  }) {
    return offline?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? unknown,
    TResult Function()? connected,
    TResult Function()? offline,
    required TResult orElse(),
  }) {
    if (offline != null) {
      return offline();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialInternetState value) initial,
    required TResult Function(_UnknownInternetState value) unknown,
    required TResult Function(_ConnectedInternetState value) connected,
    required TResult Function(_OfflineInternetState value) offline,
  }) {
    return offline(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InitialInternetState value)? initial,
    TResult? Function(_UnknownInternetState value)? unknown,
    TResult? Function(_ConnectedInternetState value)? connected,
    TResult? Function(_OfflineInternetState value)? offline,
  }) {
    return offline?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialInternetState value)? initial,
    TResult Function(_UnknownInternetState value)? unknown,
    TResult Function(_ConnectedInternetState value)? connected,
    TResult Function(_OfflineInternetState value)? offline,
    required TResult orElse(),
  }) {
    if (offline != null) {
      return offline(this);
    }
    return orElse();
  }
}

abstract class _OfflineInternetState extends InternetState {
  const factory _OfflineInternetState() = _$_OfflineInternetState;
  const _OfflineInternetState._() : super._();
}
